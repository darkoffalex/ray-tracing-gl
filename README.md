# Experimental OpenGL Raytracer

![изображение](https://downloader.disk.yandex.ru/preview/20630a7604ff43580885d2e7417f2341370ceabece65c47001781b2633690ef4/5e6bff75/0mjp6fmMbByDY9Ic_7bZfBc96dTDO9O3S17CdDqlEL6LcUpOtob5hwOK3ZEWDGSF2xg3Ifsk_42Pco2Pout_4Q==?uid=0&filename=2020-03-13_19-41-06.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&owner_uid=252757015&size=2048x2048)

Попытка реализовать трассировку лучей с использованием обычных (не RTX) шейдеров. Интерфейс библиотеки задуман таким образом, чтобы использование библиотеки рендерера-рейтрейсера по своей логике не сильно отличалось от использования обычных рендереров-растеризаторов. То есть, как и в случае с обычным графическим конвейером существует такое понятие как VAO (буфер геометрии), меш и его пространственные параметры.

## Архитектура и графический конвейер

Для того чтобы нарисовать итоговый кадр используется 2 этапа (планируется также 3-ий этап пост-обработки).

- Проход подготовки геометрии
  > Этап подразумевает 2 шейдера - вершинный и геометрический. В вершинном шейдере не происходит ничего кроме перевода координат вершин в мировое пространство (матрица модели) и отправки данных дальше в геометрический шейдер. В геометрическом шейдере происходит построение геометрического буфера (Shader Storage Buffer) из треугольников. Каждый треугольник записывается в  буфер с использованием атомарных счетчиков. При помози атомарных операций для каждого меша формируется информация о bounding box'e (AABBox) для дальнейшей оптимизации во время трассировки.
- Проход трассировки геометрии
  > В проходе трассировки рисуется квадрат на весь экран, где во фрагментном шейдере для каждого фрагмента строится луч, и если луч пересекает какой-то bounding box меша, то происходит перебор треугольников этого меша на предмет пересечения луча и треугольника. Алгоритм итеративный, набор лучей ограничен. В случае если точка пересечения обладает отржающими или преломляюзими свойствами в набор добавляется еще один луч необходимого "веса". Результат каста каждого луча прибавляется к итоговому значению цвета.

##  Сборка проекта

Проект содержит библиотеку а так-же демо windows-приложение, с примерном использование. Проект разрабатыывается с использованием среды  [СLion](https://www.jetbrains.com/clion/), но при помощи  [CMake](https://cmake.org/) можно сгенерировать проект для любой другой IDE. Если вы используете Visual Studio 2019 вы также можете открыть проект как проект CMake.

## Пример использования библиотеки

Подключите заголовочные файлы библиотеки
    
    #include "../Renderer/Renderer.h"

Убедитесь что к приложению подключена библиотека импорта. Убедитесь что в папке с exe-файлом приложения лежит динамическая библиотека glew32.dll (ее сможете найти в папке Lib проекта). Перед использованием функций библиотеки создайте OpenGL контекст. В демо-примере это делает слудющая строка

    _hglrc = win_tools::OpenGlCreateContext(_hdc);
    
Далее необходимо получить исходный код всех используемых библиотекой шейдеров. Ниже приведен пример из демо-приложения.

    // Подготовка геометрии
    std::string gpv = tools::LoadStringFromFile(tools::ShaderDir().append("geometry-prepare.vert"));
    std::string gpg = tools::LoadStringFromFile(tools::ShaderDir().append("geometry-prepare.geom"));
    std::string gpf = tools::LoadStringFromFile(tools::ShaderDir().append("geometry-prepare.frag"));

    // Трассировка
    std::string rtv = tools::LoadStringFromFile(tools::ShaderDir().append("ray-tracing.vert"));
    std::string rtf = tools::LoadStringFromFile(tools::ShaderDir().append("ray-tracing.frag"));
    
Далее необходимо инициализировать компоненты рендерера, передав размеры экрана и исходные коды шейдеров. Это можно сделать таким образром

    rtgl::Init(clientRect.right, clientRect.bottom, {gpv.c_str(), gpg.c_str(), gpf.c_str(),rtv.c_str(),rtf.c_str()})
    
Далее необходимо подготовить геометрию для мешей. Функция CreateGeometryBuffer создает объект геометрического буфера в памяти и возвращает хендл. Она принимает 2 массива - массив вершин индексов. Вершина представляет из себя структуру

    template <typename T = float>
    struct Vertex
    {
        Vec3<T> position;
        Vec3<T> color;
        Vec2<T> uv;
        Vec3<T> normal;
    };
    
В демо приложении используются вспомогательные функции для генерации геометрии примитивных геометрических объектов (куб, сфера, плоскость).
        
    rtgl::HGeometryBuffer quadBuffer = rtgl::GenerateQuadGeometry(2.0f);
    rtgl::HGeometryBuffer cubeBuffer = rtgl::GenerateCubeGeometry(1.0f);
    
Далее можно создать объекты мешей используя ранее созданную геометрию. Разные меши могут использовать одну и ту же геометрию многократно.

    rtgl::HMesh mesh1 = rtgl::CreateMesh(quadBuffer,{0.0f, 0.0f, 0.0f},{-90.0f, 0.0f, 0.0f},{3.0f, 3.0f, 1.0f});
    rtgl::HMesh mesh2 = rtgl::CreateMesh(cubeBuffer,{1.0f, 0.5f, 1.0f},{0.0f, 0.0f, 0.0f},{1.0f, 1.0f, 1.0f});
    rtgl::HMesh mesh3 = rtgl::CreateMesh(cubeBuffer,{-1.0f, 0.5f, -1.0f},{0.0f, 0.0f, 0.0f},{1.0f, 1.0f, 1.0f});
    
Вы можете устанавливать параметры материала созданным мешам

    rtgl::SetMeshMaterialSettings(mesh1,{1.0f,0.0f,0.0f},0.0f,1.0f);
    rtgl::SetMeshMaterialSettings(mesh2,{0.0f,0.0f,1.0f},0.0f,1.0f,0.2f);
    rtgl::SetMeshMaterialSettings(mesh3,{0.0f,0.0f,1.0f},0.0f,1.0f,0.5f);
    
Также можете создавать источники света

    rtgl::HMesh lightSource1 = rtgl::CreateLightSource(
                {0.0f,2.0f,0.0f},
                {0.0f,0.0f,0.0f},
                rtgl::LIGHT_POINT,0.0f,
                {0.8f,0.8f,0.8f});
                
 Для того чтобы добафить меш в геометрический буфер сцены используете следующую функцию
 
     rtgl::SetMesh(mesh1);
     
 Для добавления источника света используйте следующую функцию
 
     rtgl::SetLightSource(lightSource1);
     
 Для итоговой трассировки сцены используйте функцию
 
     rtgl::RenderScene();
     
## Состояние проекта

На даный момент проект находится на этапе разработке, многое из задуманного еще не реализовано. Имеются проблемы с производительностю и оптимизацией. Отсутствует PBR-освещение и многое другое.